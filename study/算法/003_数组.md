### 操作数组
- push 在尾部插入元素
- pop 取出最后一个元素并返回
- shift 取出第一个元素并返回
- unshift 在头部添加元素

#### 旋转数组
> 给定一个数组，将数组的元素向右移动 k 个位置，其中 k 是非负数。
> 输入: [1,2,3,4,5,6,7] 和 k = 3
> 输出: [5,6,7,1,2,3,4]

```
  const rotate = (nums, k) => {
    const l = nums.length;
    k = k % l;
    for (let i = 0; i < k; i++) {
      nums.unshift(nums.pop());
    }
    return nums;
  }
```

```
  const rotate = (nums, k) => {
    const l = nums.length;
    k = k % l;
    nums.unshift(...nums.splice(l - k, k));
    return nums;
  }
```

```
  const rotate = (nums, k) => {
    const l = nums.length;
    k = k % l;
    for (let i = l - 1; i >= 0; i--) {
      nums[i + k] = nums[i];
    }
    for (let j = k - 1; j >= 0; j--) {
      nums[j] = nums[l + j];
      nums.pop();
    }
    return nums;
  }
```


#### 只出现一次的数字
> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```
  const singleNumber = (nums) => {
    const numsGroup = nums.map(num => nums.filter(v => v === num));
    return numsGroup.find(num => num.length === 1)[0]
  }
```

```
  // 有一个数只出现了一次，其它数都出现了两次，类似乘法，则无论先后顺序，最后相同的数都会异或成0，唯一出现得数与0异或就会得到其本身。

  const singleNumber = (nums) => {
    return nums.reduce((accumulator, currentValue) => accumulator ^ currentValue);
  }
```


#### 两数之和
> 给定一个整数数组 nums 和一个目标值 target ，请你在该数组中找出和为目标值的哪两个整数，并返回他们的数组下标

```
  // 遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素
  const twoSum = (nums, target) => {
    for (let i = 0;i < nums.length; i++) {
      for (let j = i + 1; j < nums.length; j++) {
        if (nums[j] === target - nums[i]) {
          return [i, j];
        }
      }
    }
  }
```

```
  // 将每个元素的值和它的索引加到列表中，检查每个元素所对应的目标元素（target - nums[i]）是否存在表中
  const twoSum = (nums, target) => {
    const lookup = {};
  }
```















### page: 98
