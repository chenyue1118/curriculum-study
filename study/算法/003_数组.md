### 操作数组
- push 在尾部插入元素
- pop 取出最后一个元素并返回
- shift 取出第一个元素并返回
- unshift 在头部添加元素

#### 旋转数组
> 给定一个数组，将数组的元素向右移动 k 个位置，其中 k 是非负数。
> 输入: [1,2,3,4,5,6,7] 和 k = 3
> 输出: [5,6,7,1,2,3,4]

```
  const rotate = (nums, k) => {
    const l = nums.length;
    k = k % l;
    for (let i = 0; i < k; i++) {
      nums.unshift(nums.pop());
    }
    return nums;
  }
```

```
  const rotate = (nums, k) => {
    const l = nums.length;
    k = k % l;
    nums.unshift(...nums.splice(l - k, k));
    return nums;
  }
```

```
  const rotate = (nums, k) => {
    const l = nums.length;
    k = k % l;
    for (let i = l - 1; i >= 0; i--) {
      nums[i + k] = nums[i];
    }
    for (let j = k - 1; j >= 0; j--) {
      nums[j] = nums[l + j];
      nums.pop();
    }
    return nums;
  }
```


#### 只出现一次的数字
> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```
  const singleNumber = (nums) => {
    const numsGroup = nums.map(num => nums.filter(v => v === num));
    return numsGroup.find(num => num.length === 1)[0]
  }
```

```
  // 有一个数只出现了一次，其它数都出现了两次，类似乘法，则无论先后顺序，最后相同的数都会异或成0，唯一出现得数与0异或就会得到其本身。

  const singleNumber = (nums) => {
    return nums.reduce((accumulator, currentValue) => accumulator ^ currentValue);
  }
```


#### 两数之和
> 给定一个整数数组 nums 和一个目标值 target ，请你在该数组中找出和为目标值的哪两个整数，并返回他们的数组下标

```
  // 遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素
  const twoSum = (nums, target) => {
    for (let i = 0;i < nums.length; i++) {
      for (let j = i + 1; j < nums.length; j++) {
        if (nums[j] === target - nums[i]) {
          return [i, j];
        }
      }
    }
  }
```

```
  // 将每个元素的值和它的索引加到列表中，检查每个元素所对应的目标元素（target - nums[i]）是否存在表中
  const twoSum = (nums, target) => {
    const lookup = {};
    let res = [];
    nums.some((v, i) => {
      if (lookup[target - v]) {
        res = [lookup[target - v], i];
        return true;
      } else {
        lookup[v] = i;
        return false;
      }
    })
    return res;
  }
```


#### 旋转图像
> 给定一个 n × n 的二维码矩阵表示一个图像，将图像顺时针旋转90度
> 必须在原地旋转图像，需要直接修改输入的二位矩阵，不要使用另外一个矩阵来旋转图像
> 给定 matrix =
> [
>   [1,2,3],
>   [4,5,6],
>   [7,8,9]
> ],
> 原地旋转输入矩阵，使其变为:
> [
>   [7,4,1],
>   [8,5,2],
>   [9,6,3]
> ]
>
>
> 给定 matrix =
> [
>   [ 5, 1, 9,11],
>   [ 2, 4, 8,10],
>   [13, 3, 6, 7],
>   [15,14,12,16]
> ]

> 原地旋转输入矩阵，使其变为:
>  [
>   [15,13, 2, 5],
>   [14, 3, 4, 1],
>   [12, 6, 8, 9],
>   [16, 7,10,11]
>  ]

```
  // TODO:
  const rotate = (matrix) => {
    const n = matrix.length;  // n维矩阵
    for (let i = 0; i < n / 2; i++) {
      for (let j = i; j < n - i - 1; j++) {
        const temp = matrix[i][j];
        matrix[i][j] = matrix[n - 1 - j][i];
        matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
        matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
        matrix[j][n - 1 - i] = temp;
      }
    }
  }
```


#### 从排序数组中删除重复项
> 给定一个排序数组，需要在原地删除重复出现得元素，使得每个元素只出现一次，返回移除后的数组新长度

```
  const removeDuplicates = (nums) => {
    // 遍历数组
    for (let i = 1; i < nums.length; i++) {
      if (nums[i - 1] === nums[i]) {
        nums.splice(i - 1, 1);
      }
      i--;
    }
    return nums.length;
  }
```

```
  // [0, 1, 2, 3, 3, 4]
  const removeDuplicates = (nums) => {
    let count = 0;
    // 遍历数组
    for (let i = 1; i < nums.length; i++) {
      if (nums[count] !== nums[i]) {
        nums[count + 1] = nums[i];
        count++;
      }
    }
    // 因为 count 是从 0 开始的，故返回的数组长度加一
    return count + 1;
  }
```


#### 加一
> 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一

```
  // 有 6145390195186705543 溢出情况，使用 BigInt来解决
  const plusOne = (digits) => {
    return String(BigInt(digits.join('')) + 1).spilt('');
  }
```

```
  // [1, 9]
  const plusOne = (digits) => {
    for (let i = digits.length - 1; i >= 0; i--) {
      digits[i]++;
      digits[i] = digits[i] % 10;
      if (digits[i] !== 0) {
        return digits;
      }
    }
    // digits.splice(0, 0, 1);
    // return digits;
  }
```


#### 买卖股票的最佳时机II
> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格

```
  TODO:
```


#### 移动零
> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序
> 必须在原数组上操作，数组的filter 和sort 算法，都是不考虑的
> 切记不要边遍历数组边修改数组长度，如：splice，push，pop等

```
  const moveZeroes = (nums) => {
    let j = 0;
    for (let i = 0; i < nums.length; i++) {
      if (nums[i] !== 0) {
        nums[j] = nums[i];
        j++;
      }
    }
    nums.fill(0, j, nums.length);
  }
```

```
  // [1, 0, 0, 4] j-1 i-3
  const moveZeroes = (nums) => {
    let j = 0;
    let temp = '';
    for (let i = 0; i < nums.length; i++) {
      if (nums[i] !== 0) {
        temp = nums[j];
        nums[j] = nums[i];
        nums[i] = temp;
        j++;
      }
    }
  }
```


#### 两个数组的交集
> 给定两个数组，计算数组交集
> 1. 输出结果中每个元素出现得次数，应与元素在两个数组出现得次数一致
> 2. 可以不考虑输出结果的顺序

```
  // 遍历第一个数组，将第一个数组的值、该值出现得次数，以（key：value）的形式存储下来，接着遍历第二个数组，判断是否在（key：value）中存在，存在 value 减去 1，继续
  const intersect = (nums1, nums2) => {
    const hashObject = {};
    for (let i = 0; i < nums1.length; i++) {
      if (hashObject[nums1[i]]) {
        hashObject[nums1[i]] += 1;
      } else {
        hashObject[nums1[i]] = 1;
      }
    }
    const result = [];
    for (let j = 0; j < nums2.length; j++) {
      if (hashObject[nums2[j]]) {
        result.push(nums2[j]);
        hashObject[nums2[j]] -= 1;
      }
    }
    return result;
  }
```

```
const intersect = (nums1, nums2) => {
  const longerArr = nums1.length > nums2.length ? num1 : num2;
  const shorterArr = nums1.length > nums2.length ? nums2 : nums1;
  const result = [];
  for (let i = 0; i < shorterArr.length; i++) {
    if (longerArr.indexOf(shorterArr[i]) > -1) {
      result.push(shorterArr[i]);
      longerArr.splice(longerArr.indexOf(shorterArr[i]), 1);
    }
  }
  return result;
}
```


#### 一周中的第几天
> 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
> 输入为三个整数： day、month 和 year，分别表示日、月、年
> 返回 其中一个 { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday }
> 说明：给定的日期一定是在 1971 到2100 年之间有效的日期

```
  // 先算出 1970-12-31 距今一共有多少天 (1970年12月31日为星期四，即初始值为4)
  // 然后对得到的天数对7取余，得到数字5，表示当前星期五
  const dayOfTheWeek = (day, month, year) => {
    const Month = [];
    const Week = [];
    // 1970年12月31日为星期四，即初始值为4
    let count = 4;
  }
```















### page: 118
