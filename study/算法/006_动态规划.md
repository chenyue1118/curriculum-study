#### 动态规划
> 是通过组合组合子问题的解决，从而解决整个问题的算法
> 动态规划适用于子问题不是独立的情况，对每个子问题只求解一次，使用数组来建立一张表格，来存放被分解成众多子问题的解，从而避免重复计算相同的子问题。

##### 最大子序和
> 给定一个整数数组 nums ， 找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```
  // 从数组最左边开始于数组右边数据依次相加，将相加之后数据进行比较，比较之后，最大值为最终结果
  // [-2, 1, -3, 4, -1, 2, 1, -5, 4] =>  6  (连续最大子数组 [4, -1, 2, 1])
  const maxSubArray = (nums) => {
    let sum = 0;
    let maxNumber = 0;

    for (let i = 0; i < nums.length; i++) {
      for (let j = i; j < nums.length; j++) {
        sum = 0;
        for (let k = i; k <= j; k++) {
          sum += nums[k];
        }
        if (sum > maxNumber) {
          maxNumber = sum;
        }
      }
    }
    return maxNumber;
  }
```

```
  // 数组从最左端开始依次和右端数据相加，两数之和为最大数 sum 。下一次相加之后和最大数进行比较，较大数赋值 sum， 由于有负数存在，如果两数相加之后为负数，则两数之和后的最大数为上一个数。
  // [1, -3, 4, -1, 2, 1, -5, 4, 3]
  const maxSubArray = (nums) => {
    let sum = nums[0];
    let n = nums[0];
    for (let i = 1; i < nums.length; i++) {
      if (n > 0) {
        n += nums[i];
      } else {
        n = nums[i];
      }
      if (sum < n) sum = n; // 相加后的值和最大值作比较
    }
    return sum;
  }
```


#### 爬楼梯
> 假设你正在爬楼梯。需要 n 阶你才能达到楼顶。
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶

```
  // 递归函数一
  const climbStairs = (n) => {
    if (n <= 2) {
      return n;
    } else {
      return climbStairs(n - 1) + climbStairs(n - 2);
    }
  }

  // 递归函数二
  const fn = (n, map) => {
    if (n <= 2) {
      return n;
    }
    const result = map[n];
    if (result) {
      return result;
    } else {
      let num = fn(n - 1, map) + fn(n - 2, map);
      map[n] = num;
      return num;
    }
  }

  const climbStairs = (n) => {
    const map = {};
      return fn(n, map);
  }
```

```
  // F(n) = F(n - 1) + F(n - 2)
  const climbStairs = (n) => {
    const result = [0, 1, 2];
    for (let i = 3; i <= n; i++) {
      result[i] = result[i - 1] + result[i - 2];
    }
    return result[n];
  }
```


#### 买卖股票的最佳时机
> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多，只允许完成一次交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。

```
  // [7, 1, 5, 3, 6, 4]
  const maxProfit = (prices) => {
    let maxProfit = 0;

    const getMax = (i) => {
      let max = prices[i + 1]; // 获取第 i 天后股票价格中的最大值

      for (let j = i + 1; j < prices.length; j++) {
        if (prices[j] > max) {
          max = prices[j];
        }
      }

      return max;
    }

    for (let i = 0; i < prices.length - 1; i++) {
      const max = getMax(i) - prices[i];
      maxProfit = Math.max(maxProfit, max);
    }

    return maxProfit;
  }
```

```
  // 求最大差值
  const maxProfit = (prices) => {
    let minPrice = 0;
    let maxPrice = 0;

    prices.forEach((price, index) => {
      if (index === 0) {
        minPrice = price;
      } else if (price < minPrice) {
        minPrice = price;
      } else if (price - minPrice > maxPrice) {
        maxPrice = price -minPrice;
      }
    })

    return maxPrice;
  }
```

```
  // [7, 1, 5, 3, 6, 4]
  const maxProfit = (prices) => {
    let maxProfit = 0; // 最大收益
    let profits = [0]; // 每日最大收益存入数组，第一天初始化为 0

    for (let i = 0; i < prices.length; i++) {
      // 计算每日可获取的最大收益值
      profits[i] = Math.max(0, profits[i - 1] + (prices[i] - prices[i - 1]));
      if (profits[i] > maxProfit) {
        maxProfit = profits[i];
      }
    }

    return maxProfit;
  }
```


#### 打家劫舍
> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
> 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
> 输入: [2,7,9,3,1]
> 输出: 12
> 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12

```
  // [2, 7, 9, 3, 1, 3]
  const rob = (nums) => {
    const len = nums.length;
    if (len === 0) return 0;
    if (len === 1) return nums[0];
    if (len === 2) return Math.max(nums[0], nums[1]);

    let sumTemp = 0;
    let sumBefore = nums[0];
    let sumAfter = Math.max(num[0], num[1]);
    let i = 2;
    while (i < len) {
      sumTemp = Math.max(sumAfter, sumBefore + num[i]);
      sumBefore = sumAfter;
      sumAfter = sumTemp;
      i++;
    }
    return sumAfter;
  }
```










#### 269
