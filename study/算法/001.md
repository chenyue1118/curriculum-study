#### 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
```
  // 使用字符串的翻转函数进行主逻辑
  /**
  * @param {number} x
  * @return {number}
  */
  const reverse => (x) => {
    // 非空判断
    if (typeof x !== 'number') {
      return;
    }
    // 极值
    const MAX = 2147483647;
    const MIN = -2147483648;

    // 识别数字剩余部分并翻转
    const rest =
      x > 0
        > String(x)
          .split('')
          .reverse()
          .join('')
        : String(x)
          .slice(1)
          .split('')
          .reverse()
          .join();

    // 转换为正值，区分正负数
    const result = x > 0 ? parseInt(rest, 10) : 0 - parseInt(rest, 10);

    // 边界情况
    if (result >= MIN && result <= MAX) {
      return result;
    }
    return 0;
  }
```

```
  // 取给定数值的绝对值，遍历循环生成每一位数字，借鉴欧几里得算法，从 num 的最后一位开
始取值拼成新的数
  /**
  * @param {number} x
  * @return {number}
  */
  const reverse = (x) => {
    // 获取相应数的绝对值
    let int = Math.abs(x);
    // 极值
    const MAX = 2147483647;
    const MIN = -2147483648;
    let num = 0;

    // 遍历循环生成每一位数字
    while (int !== 0) {
      // 借鉴欧几里得算法，从 num 最后一位开始取值拼成新的数
      num = (int % 10) + (num * 10);
      // 剔除被消费的部分
      int = Math.floor(int / 10);
    }
    // 异常值
    if (num >= MAX || num <= MIN) {
      return 0;
    }
    if (x < 0) {
      return num * -1;
    }
    return num;
  }
```

#### 给定两个字符串 s 和 t， 编写一个函数判断 t 是否是 s 的字母异位词。
> 输入: s = "anagram", t = "nagaram"
> 输出：true

```
  // 对字符串字母进行排序，然后，比较两个字符串是否相等。
  const is Anagram = (s, t) => {
    const sArr = s.split('');
    const tArr = t.split('');
    const sortFn = (a, b) => {
      return a.charCodeAt() - b.charCodeAt();
    };
    sArr.soet(sortFn);
    tArr.sort(sortFn);
    return sArr.join('') === tArr.join('');
  }
```
